package com.mystudio.themaze;

import java.util.ArrayList;

import org.mini2Dx.core.graphics.Graphics;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;

public class Maze 
{
	private int mapScale;
	private int [][] matrix;
	private ArrayList<Integer> playerSpawn;
	private ArrayList<ArrayList<Integer>> enemiesSpawn;	
	private ArrayList<ArrayList<Integer>> teleporters;
	private ArrayList<Item> items;
	
	/**
	 * 
	 * @param map : the mapTranslator object containing the game matrix
	 * @param player : player instance
	 */
	public Maze(mapTranslator map)
	{
		matrix = new int[map.getMatrix().length][map.getMatrix()[0].length];
		matrix = map.getMatrix();
		
		playerSpawn = new ArrayList<Integer>();
		enemiesSpawn = new ArrayList<ArrayList<Integer>>();
		teleporters = new ArrayList<ArrayList<Integer>>();
		items = new ArrayList<Item>();
		
		mapScale = map.getTileSize();
		initialiseDefaultPositionPlayer();
		initialiseDefaultPositionEnemy();
		initialiseTeleporterPosition();
	}
	
	/**
	 * Look for the position of the player's spawn in the matrix 
	 */
	private void initialiseDefaultPositionPlayer() 
	{
		for (int i=0; i<matrix.length; i++)
		{
			for (int j=0; j<matrix[0].length; j++) 
			{
				if(matrix[i][j]==2) 
				{
					playerSpawn.add(i);
					playerSpawn.add(j);
				}
			}	
		}
	}
	
	/**
	 * Look for the position of the enemies' spawn in the matrix
	 */
	private void initialiseDefaultPositionEnemy() 
	{
		for (int i=0; i<matrix.length; i++)
		{
			for (int j=0; j<matrix[0].length; j++) 
			{
				if(matrix[i][j]==3) 
				{
					ArrayList<Integer> pos = new ArrayList<Integer>();
					pos.add(i);
					pos.add(j);
					enemiesSpawn.add(pos);
				}
			}	
		}		
	}
	
	private void initialiseTeleporterPosition() 
	{
		for (int i=0; i<matrix.length; i++)
		{
			for (int j=0; j<matrix[0].length; j++) 
			{
				if(matrix[i][j]==9) 
				{
					ArrayList<Integer> pos = new ArrayList<Integer>();
					pos.add(i);
					pos.add(j);
					teleporters.add(pos);
				}
			}	
		}		
	}
	
	public int[] teleportPlayer(int x, int y)
	{
		System.out.println("TELEPORT !!!!!!");
		int rand = 0;
		int newX = 0;
		int newY = 0;
		do 
		{
			rand = (int)(Math.random() * (4-0));
			newX = teleporters.get(rand).get(0);
			newY = teleporters.get(rand).get(1);
			System.out.println("new teleporter : "+newX+" / "+newY+" and old teleporter "+x+" / "+y);
		} while (teleporters.get(rand).get(0) == x && teleporters.get(rand).get(1) == y );
		int[] newPos = {newX,newY};
		return newPos;
	}
	
	/**
	 * Paint the game matrix which was generated by the image skeleton
	 * @param g
	 */
	public void PaintMaze(Graphics g) 
	{
		for (int i=0; i<matrix.length; i++) 
		{
			for (int j=0; j<matrix[0].length; j++) 
			{
				switch(matrix[i][j])
				{
					case 0:
						g.setColor(Color.GRAY);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
					case 1:
						g.setColor(Color.BLACK);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
					case 2:
						g.setColor(Color.BLUE);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
					case 3:
						g.setColor(Color.PINK);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
					case 4:
						g.setColor(Color.RED);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
					case 5:
						g.setColor(Color.BROWN);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
					case 6:
						g.setColor(Color.GREEN);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
					case 9:
						g.setColor(Color.PURPLE);
						g.fillRect(j*mapScale,i*mapScale,mapScale,mapScale);
						break;
				 }
			 }
		 } 
	 }
	
	/**
	 * Paint the map displayed to the user
	 * @param g
	 * @param path : map path
	 */
	public void paintTrueMap(Graphics g, String path)
	{
		Texture map = new Texture(path);
		g.drawTexture(map, 0, 0, map.getWidth(), map.getHeight());
	}
	
	/**
	 * Paint the items
	 * @param g
	 */
	public void paintItems(Graphics g) 
	{
		if(items.size()>0) 
    	{
	    	for(int i=0; i<items.size(); i++) 
	    	{
	    		items.get(i).render(g);
	    	}
    	}
	}
	
	public void addItem(Item item) 
	{
		items.add(item);
	}

	public int[][] getMatrix() 
	{
		return matrix;
	}

	public int getMapScale()
	{
		return mapScale;
	}
	
	public int getPlayerSpawnX()
	{
		return playerSpawn.get(0);
	}
	public int getPlayerSpawnY()
	{
		return playerSpawn.get(1);
	}
	
	public int getEnemySpawnX(int enemyNb)
	{
		return enemiesSpawn.get(enemyNb).get(0);
	}
	
	public int getEnemySpawnY(int enemyNb)
	{
		return enemiesSpawn.get(enemyNb).get(1);

	}
	
	public ArrayList<Item> getItems()
	{
		return items;
	}
}
